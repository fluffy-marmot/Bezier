<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1, width=device-width">

        <script src="/static/jquery-3.7.1.min.js"></script>

        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">    
        <link href="/static/styles.css" rel="stylesheet">

        <title>Bezier Curves</title>
    </head>

    <body>

        <div class="container">
            <canvas id="canvas")>Your browser does not support HTML5 Canvas.</canvas>
        </div>
        <div class="container">
            <input type="range" disabled min="0" max="0" step="0.01" value="0" id="slider">
            <button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off" id="tangent">Tangent Vector</button>
            <button type="button" id="box">Bounding Box</button>
            <button type="button" id="lc">Linear Combination</button>
            <button type="button" id="lerps">Lerps</button>
            <button type="button" id="osculating">Osculating Circle</button>
        </div>

        <script src="static/mathy.js"></script>
        <script>

            function redraw() {
                visibility_checks();

                context.fillStyle = BACKGROUND_COLOR;
                context.fillRect(0, 0, canvas.width, canvas.height);

                for (let p of pts_for_bezier) {
                    p.draw(context);
                }
                for (let o of objects) {
                    o.draw(context);
                }
            }

            function findActiveObj() {
                for (let o of objects) {
                    if (o instanceof CubicBezier) {
                        for (let pt of o.points) {
                            if (pt.mode == POINT_MOVING)
                                return pt;
                        }
                    } else if (o instanceof Spline) {
                        for (let c of o.curves) {
                            for (let pt of c.points) {
                                if (pt.mode == POINT_MOVING)
                                    return pt;
                            }
                        }
                    }
                }
                return null;
            }

            // Adapted from https://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
            function drawArrow(fromx, fromy, tox, toy, ctx, color, width = 4, alpha = 1.0, dash = [], headlen = 15) {
                // This makes it so the end of the arrow head is located at tox, toy
                let angle = Math.atan2(toy - fromy, tox - fromx);
                tox -= Math.cos(angle) * ((width * 1.15));
                toy -= Math.sin(angle) * ((width * 1.15));

                //starting path of the arrow from the start square to the end square and drawing the stroke
                ctx.setLineDash(dash);
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(fromx, fromy);
                ctx.lineTo(tox, toy);
                ctx.stroke();
                ctx.setLineDash([]);

                //starting a new path from the head of the arrow to one of the sides of the point
                ctx.beginPath();
                ctx.moveTo(tox, toy);
                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));

                //path from the side point of the arrow, to the other side point
                ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));

                //path from the side point back to the tip of the arrow, and then again to the opposite side point
                ctx.lineTo(tox, toy);
                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));

                //draws the paths created above
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.stroke();
                ctx.fillStyle = color;
                ctx.fill();

                ctx.lineWidth = 1;
                ctx.globalAlpha = 1.0;
            }

            const canvas = document.getElementById('canvas');
            const slider = document.getElementById('slider');
            const box_button = document.getElementById('box');
            let show_box = false;
            const lerps_button = document.getElementById('lerps');
            let show_lerps = false;
            const tangent_button = document.getElementById('tangent');
            let show_tangent = false;
            const context = canvas.getContext('2d');
            let show_lc = false;
            const lc_button = document.getElementById('lc');
            let show_osculating = false;
            const osculating_button = document.getElementById('osculating');

            let objects = [];
            let pts_for_bezier = [];
            let dot_selected = -1;
            let is_dot_selected = false;
            let ignore_click = false;
            let mousedown_x, mousedown_y;

            objects.push(new Spline());
            objects.push(new BernsteinBox());

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            redraw();

            function visibility_checks() {
                for (let o of objects) {
                    if (o instanceof Spline) {
                        for (let i = 0; i < o.curves.length; i++ ) {
                            if (slider.value === slider.max && i === o.curves.length - 1) {
                                o.curves[i].show_lerps = show_lerps;
                                o.curves[i].show_tangent = show_tangent;
                                o.curves[i].show_lc = show_lc;
                                o.curves[i].show_osculating = show_osculating;
                                o.curves[i].t_param = 1.0;
                            } else if (Math.floor(slider.value) === i) {
                                o.curves[i].show_lerps = show_lerps;
                                o.curves[i].show_tangent = show_tangent;
                                o.curves[i].show_lc = show_lc;
                                o.curves[i].show_osculating = show_osculating;
                                o.curves[i].t_param = slider.value - Math.floor(slider.value);
                            } else {
                                o.curves[i].show_lerps = false;
                                o.curves[i].show_tangent = false;
                                o.curves[i].show_lc = false;
                                o.curves[i].show_osculating = false;
                            }
                            o.curves[i].show_normal = o.curves[i].show_tangent; // for now
                            o.curves[i].show_box = show_box;
                        }
                    } else if (o instanceof BernsteinBox) {
                        o.t_param = slider.value - Math.floor(slider.value);
                        if (slider.value === slider.max) {
                            o.t_param = 1.0;
                        }
                    }
                }
            }

            function canvas_coords(e) {
                let bounding_rect = canvas.getBoundingClientRect();
                return {
                    'x': e.clientX - bounding_rect.left,
                    'y': e.clientY - bounding_rect.top
                }
            }

            $(function() {
                $('#canvas').mousedown( (e) => {
                    mouse = canvas_coords(e);
                    mousedown_x = mouse.x, mousedown_y = mouse.y;
                    ignore_click = false;

                    for (let o of objects) {
                        if (o instanceof Spline) {
                            for (let c of o.curves) {
                                for (let pt of c.points) {
                                    d = Math.hypot(pt.x - mouse.x, pt.y - mouse.y);
                                    if (d <= POINT_DRAW_RADIUS + 2) {
                                        pt.mode = POINT_MOVING;
                                        ignore_click = true;
                                        redraw();
                                        return;
                                    }
                                }
                            }
                        }
                    }
                });

                $('#canvas').mouseup( (e) => {
                    mouse = canvas_coords(e);

                    if (Math.hypot(mousedown_x - mouse.x, mousedown_y - mouse.y) > 3)
                        ignore_click = true;

                    active_obj = findActiveObj();
                    if (active_obj !== null) {
                        if (active_obj instanceof Point) {
                            active_obj.mode = POINT_STANDARD;
                        }
                    }
                });

                $('#canvas').mousemove( (e) => {
                    mouse = canvas_coords(e);

                    active_obj = findActiveObj();
                    if (active_obj !== null) {
                        if (active_obj instanceof Point) {
                            active_obj.move(mouse.x, mouse.y)
                            for (let o of objects) {
                                if (o instanceof Spline) {
                                    o.check_constraints();
                                    for (let c of o.curves) {
                                        if (c.points.includes(active_obj)) {
                                            c.calc_center();
                                        }
                                    }
                                }
                            }
                            redraw();
                        }
                    }
                });

                $('#canvas').click( (e) => {
                    if (!ignore_click) {
                        mouse = canvas_coords(e);

                        new_point = new Point(mouse.x, mouse.y);
                        new_point.mode = POINT_FORMING_BEZIER;
                        pts_for_bezier.push(new_point);
                        for (let o of objects) {
                            if (o instanceof Spline && o.active && o.next_curve_points === pts_for_bezier.length) {
                                for (let pt of pts_for_bezier) {
                                    pt.mode = POINT_STANDARD;
                                }
                                o.add_curve(pts_for_bezier);
                                pts_for_bezier = [];
                                slider.disabled = false;
                                slider.max = o.curves.length
                                break;
                            }
                        }
                    }
                    redraw();
                });
                $('#slider').on('input', () => {
                    redraw();
                });

                box_button.addEventListener("click", function() {
                    show_box = !show_box;
                    for (let o of objects) {
                        if (o instanceof Spline) {
                            for (let c of o.curves) {
                                c.show_box = show_box;
                            }

                        } else if (o instanceof CubicBezier) {
                            o.show_box = show_box;
                        }
                    }
                    redraw();
                });

                lerps_button.addEventListener("click", function() {
                    show_lerps = !show_lerps;
                    redraw();
                });

                tangent_button.addEventListener("click", function() {
                    show_tangent = !show_tangent;
                    redraw();
                });

                lc_button.addEventListener("click", function() {
                    show_lc = !show_lc;
                    redraw();
                });

                osculating_button.addEventListener("click", function() {
                    show_osculating = !show_osculating;
                    redraw();
                });

                $(window).on('resize', () => {
                    canvas.width = canvas.offsetWidth, canvas.height = canvas.offsetHeight;
                    redraw();
                });
            });

        </script>

    </body>

</html>